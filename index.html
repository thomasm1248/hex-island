<!DOCTYPE html>
<html>
<head>
	<title>Hex Island</title>
	<style>

* {
	margin: 0;
	padding: 0;
}

body {
	overflow: hidden;
}

	</style>
</head>
<body>
	<canvas id="canvas"></canvas>
	<script src="/socket.io/socket.io.js"></script>
	<script>



// Socket setup
var socket = io();

// Globals
var config = {
	cameraInertia: 0.95,
	cellSize: 120,
	tileSize: 63,
	steepTileSize: 50,
	inclineShift: 10,
	viewDist: 3,
	loadDist: 4,
	mapLoadTime: 10
};
var mapLoadTimer = 0;
var mouse = {
	x: 0,
	y: 0
};
var character;
var characterLoaded = false;
var smoothShift;
var cameraPlaced = false;
var map;
var gameTime;
var entities = [];

// Util functions
function hexDist(a, b) {
	var d = {
		x: b.x - a.x,
		y: b.y - a.y
	};
	// Test the x and y coordinates
	if(d.x * d.y >= 0) {
		// If they have the same sign
		// return the sum
		return Math.abs(d.x + d.y);
	} else {
		// If they have different signs
		// return the smallest
		return Math.max(Math.abs(d.x), Math.abs(d.y));
	}
}
function v(x, y) {
	return {
		x: x,
		y: y
	};
}
function addV(a, b) {
	return v(a.x + b.x, a.y + b.y);
}
function subV(a, b) {
	return v(a.x - b.x, a.y - b.y);
}
var hexX = v(Math.cos(-Math.PI/6), Math.sin(-Math.PI/6));
var hexY = v(Math.cos(Math.PI/6), Math.sin(Math.PI/6));
function hexCoords(x, y) {
	x *= config.cellSize;
	y *= config.cellSize;
	return v(x*hexX.x + y*hexY.x, x*hexX.y + y*hexY.y);
}
function hexTranslate(x, y) {
	var coords = hexCoords(x, y);
	ctx.translate(coords.x, coords.y);
}
function hexMoveTo(x, y) {
	var coords = hexCoords(x, y);
	ctx.moveTo(coords.x, coords.y);
}
function hexLineTo(x, y) {
	var coords = hexCoords(x, y);
	ctx.lineTo(coords.x, coords.y);
}
var directions = {
	"up": v(1,-1),
	"down": v(-1,1),
	"left-d": v(-1,0),
	"left-u": v(0,-1),
	"right-d": v(0,1),
	"right-u": v(1,0)
};
function clamp(a, x, b) {
	if(x < a) return a;
	if(x > b) return b;
	return x;
}

// Game event functions
function drawMap() {
	ctx.save();
	// Draw black background
	ctx.fillStyle = "black";
	ctx.fillRect(0, 0, canvas.width, canvas.height);
	// Print useful info (beginning of a HUD)
	if(characterLoaded) {
		ctx.fillStyle = "white";
		ctx.fillText("Character Name: " + character.name, 10, 20);
		ctx.fillText("Character ID: " + character.id, 10, 35);
		ctx.fillText("Elevation: " + map.getCamTile(0,0).height, 10, 50);
		ctx.fillText("Camera: " + map.cameraPos.x + ' ' + map.cameraPos.y, 10, 65);
		ctx.fillText("Day: " + gameTime.day + "  Hour: " + gameTime.hour, 10, 80);
	}
	// Move to center of screen
	ctx.translate(canvas.width/2, canvas.height/2);
	ctx.translate(smoothShift.x, smoothShift.y);
	// Draw tiles within view
	var currentHeight = map.getCamTile(0,0).height;
	for(var y = -config.viewDist; y <= config.viewDist; y++) {
		for(var x = config.viewDist; x >= -config.viewDist; x--) {
			if(hexDist(v(0,0), v(x,y)) > config.viewDist) continue;
			var tile = map.getCamTile(x, y);
			ctx.save();
			hexTranslate(x, y);
			var color = "black";
			switch(tile.type) {
				case "water":
					color = "#172836";
					break;
				case "dirt":
					color = "#6e4e31";
					break;
				case "sand":
					color = "#fbedab";
					break;
				case "grass":
					color = "#69b42e";
					break;
				case "shrub":
					color = "#2b4e10";
					break;
				case 'tree':
					color = "#40301c";
					break;
				case 'rocks':
					color = "#2a2a2a";
					break;
				case 'stone':
					color = "#404040";
					break;
				case 'undergrowth':
					color = '#23290f';
					break;
				case 'herb':
					color = '#5f7a13';
					break;
			}
			ctx.fillStyle = color;
			ctx.beginPath()
			var heightDiff = tile.height - currentHeight;
			var size = Math.abs(heightDiff) <= 1 ?
				config.tileSize : config.steepTileSize;
			heightDiff = clamp(-3, heightDiff, 3);
			ctx.translate(0, -heightDiff * config.inclineShift);
			ctx.moveTo(size, 0);
			for(var rot = Math.PI/3; rot < Math.PI*2; rot += Math.PI/3) {
				ctx.lineTo(Math.cos(rot)*size, Math.sin(rot)*size);
			}
			ctx.fill();
			ctx.strokeStyle = "black";
			ctx.lineWidth = 2;
			ctx.stroke();
			ctx.fillStyle = "black";
			//ctx.fillText(tile.type, -30, 0);
			//ctx.fillText(tile.height, -30, 15);
			ctx.restore();
		}
	}
	// Draw entities
	for(var i = 0; i < entities.length; i++) {
		if(hexDist(map.cameraPos, entities[i].pos) > config.viewDist) continue;
		ctx.save();
		hexTranslate(
			-map.cameraPos.x + entities[i].pos.x,
			-map.cameraPos.y + entities[i].pos.y
		);
		ctx.beginPath();
		ctx.arc(0, 0, 20, 0, Math.PI*2);
		ctx.fillStyle = "white";
		ctx.strokeStyle = "black";
		ctx.fill();
		ctx.stroke();
		ctx.restore();
	}
	// Finish
	ctx.restore();
}
function takeAction(direction) {
	socket.emit('action', direction);
}

// Map manager
function Map(camX, camY) {
	this.tiles = {};
	this.cameraPos = {
		x: camX,
		y: camY
	};
}
Map.prototype.id = function(x, y) {
	return x + "," + y;
};
Map.prototype.getTile = function(x, y) {
	var id = this.id(x, y);
	if(this.tiles[id] === undefined) {
		return {
			x: x,
			y: y,
			height: 0,
			type: '',
			data: {}
		};
	} else {
		return this.tiles[id];
	}
};
Map.prototype.getCamTile = function(x, y) {
	return this.getTile(this.cameraPos.x + x, this.cameraPos.y + y);
};
Map.prototype.setTile = function(x, y, type, height, data) {
	this.tiles[this.id(x, y)] = {
		type: type,
		x: x,
		y: y,
		height: height,
		data: data
	};
};
Map.prototype.purgeTiles = function(cutoffDist) {
	for(var id in this.tiles) {
		if(hexDist(this.cameraPos, this.tiles[id]) > cutoffDist) {
			delete this.tiles[id];
		}
	}
};
Map.prototype.loadTiles = function() {
	for(var x = -config.loadDist; x <=config.loadDist; x++) {
		for(var y = -config.loadDist; y <= config.loadDist; y++) {
			if(hexDist(v(x, y), v(0, 0)) <= config.loadDist) {
				var tile = map.getCamTile(x, y).type;
				if(tile === '') {
					socket.emit('request-tile', v(this.cameraPos.x + x, this.cameraPos.y + y));
				}
			}
		}
	}
};

// Setup the canvas
var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");

// Setup game environment
map = new Map(0,0);

// Handle user input events
window.onclick = function(e) {
	mouse.x = e.clientX;
	mouse.y = e.clientY;
};
window.onkeydown = function(e) {
	switch(e.keyCode) {
		case 87://w
			takeAction("up");
			break;
		case 83://s
			takeAction("down");
			break;
		case 65://a
			takeAction("left-d");
			break;
		case 68://d
			takeAction("right-d");
			break;
		case 81://q
			takeAction("left-u");
			break;
		case 69://e
			takeAction("right-u");
			break;
		case 32://space
			takeAction("wait");
			break;
		case 88://x
			takeAction("cancel");
			break;
	}
};

// Socket events
socket.on('character-init', function(characterInfo) {
	character = characterInfo;
	characterLoaded = true;
	// Throw away tiles we already had to avoid a weird bug
	map.purgeTiles(-1);
});
socket.on('tile', function(tile) {
	map.setTile(tile.x, tile.y, tile.type, tile.height, tile.data);
});
socket.on('entities', function(updatedEntities) {
	entities = updatedEntities;
});
socket.on('move-camera', function(pos) {
	if(cameraPlaced) {
		var d = v(
			pos.x - map.cameraPos.x,
			pos.y - map.cameraPos.y
		);
		d = hexCoords(d.x, d.y);
		smoothShift.x += d.x;
		smoothShift.y += d.y;
	} else {
		cameraPlaced = true;
	}
	map.cameraPos = pos;
});
socket.on('time', function(time) {
	gameTime = time;
});

// Draw loop
smoothShift = v(0, 0);
function draw() {
	window.requestAnimationFrame(draw);
	// Auto-resize canvas
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	// Load tiles
	mapLoadTimer--;
	if(mapLoadTimer < 0) {
		map.loadTiles();
		mapLoadTimer = config.mapLoadTime;
	}
	// Move camera to position of character
	for(var i = 0; i < entities.length; i++) {
		if(entities[i].id === character.id) {
			// Prepare to smooth the camera motion
			var d = v(
				entities[i].pos.x - map.cameraPos.x,
				entities[i].pos.y - map.cameraPos.y
			);
			d = hexCoords(d.x, d.y);
			smoothShift.x += d.x;
			smoothShift.y += d.y;
			// Set camera position
			map.cameraPos = entities[i].pos;
			break;
		}
	}
	// Smooth camera motion
	smoothShift.x *= config.cameraInertia;
	smoothShift.y *= config.cameraInertia;
	// Draw everything
	drawMap();
}
draw();



	</script>
</body>
</html>
